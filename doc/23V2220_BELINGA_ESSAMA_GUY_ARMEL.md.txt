Voici un programme en C qui calcule ùëé√óùëè
a√ób pour ùëé,ùëè>0
a,b>0 en n‚Äôutilisant exclusivement l‚Äôop√©ration +1 (op√©rateur ++).
L‚Äôid√©e : on impl√©mente une addition add(x,y) qui incr√©mente x y fois (avec ++), puis la multiplication comme b additions de a.

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

/* Addition par incr√©ments : retourne x + y en n'utilisant que ++ */
unsigned long long add_by_inc(unsigned long long x, unsigned long long y) {
    unsigned long long i = 0;
    while (i < y) {
        ++x;   /* uniquement +1 */
        ++i;
    }
    return x;
}

/* Multiplication par additions r√©p√©t√©es : retourne a * b */
unsigned long long mul_by_add(unsigned long long a, unsigned long long b) {
    unsigned long long result = 0;
    unsigned long long i = 0;
    while (i < b) {
        result = add_by_inc(result, a); /* addition de 'a' √† result */
        ++i;
    }
    return result;
}

int main(void) {
    unsigned long long a, b;
    if (scanf("%llu %llu", &a, &b) != 2) {
        fprintf(stderr, "Entr√©e invalide\n");
        return 1;
    }

    if (a == 0 || b == 0) {
        printf("0\n");
        return 0;
    }

    /* V√©rification simple d'overflow (optionnel) */
    if (a > ULLONG_MAX / b) {
        fprintf(stderr, "Overflow possible pour %llu * %llu\n", a, b);
        return 1;
    }

    unsigned long long prod = mul_by_add(a, b);
    printf("%llu\n", prod);
    return 0;
}


Remarques :
Le code n‚Äôutilise jamais + avec un autre entier ; seules des incr√©mentations (++) sont employ√©es.
J‚Äôai utilis√© unsigned long long pour r√©duire le risque d‚Äôoverflow.

